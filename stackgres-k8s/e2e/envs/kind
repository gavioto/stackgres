#!/bin/sh

KIND_NAME="${KIND_NAME:-kind}"
KIND_NODES="${KIND_NODES:-1}"
KIND_LOCK_PATH="${KIND_LOCK_PATH:-$TARGET_PATH/kind-lock}"

KIND_CONTAINERD_SHARED_CACHE_PATH="${KIND_CONTAINERD_SHARED_CACHE_PATH:-$TARGET_PATH/kind-cache}"
KIND_CONTAINERD_SHARED_CACHE_RUN_ID="${KIND_CONTAINERD_SHARED_CACHE_RUN_ID:-$(date +%s)}"
KIND_CONTAINERD_SHARED_CACHE_SIZE="${KIND_CONTAINERD_SHARED_CACHE_SIZE:-100G}"
KIND_CONTAINERD_SHARED_CACHE_IMAGE_TAGS="${KIND_CONTAINERD_SHARED_CACHE_IMAGE_TAGS:-$IMAGE_TAG}"
KIND_CONTAINERD_SHARED_CACHE_EXTRA_IMAGES_FILES="${KIND_CONTAINERD_SHARED_CACHE_EXTRA_IMAGES_FILES:-$E2E_PULLED_IMAGES_PATH}"

check_kind_version() {
  if ! kind version | grep -q -F 'kind v0.11.0 '
  then
    echo "kind v0.11.0 is required"
    return 1
  fi
}

get_k8s_env_version() {
  echo "Kind version $(kind version | cut -d ' ' -f 2)"
  echo
}

update_k8s_config() {
  check_kind_version

  mkdir -p "$HOME/.kube"
  if [ "$K8S_FROM_DIND" = true ]
  then
    if docker network ls --format '{{ .Name }}' | grep -q '^kind$'
    then
      local CONTAINER_NAME="$(docker ps --format '{{ .Names }}' | grep "^$(hostname)")"
      if [ -z "$CONTAINER_NAME" ]
      then
        CONTAINER_NAME="$(docker ps --format '{{ .ID }}' | grep "^$(hostname)")"
      fi
      docker inspect "$CONTAINER_NAME" \
        -f '{{ range $key,$value := .NetworkSettings.Networks }}{{ printf "%s\n" $key }}{{ end }}' \
        | grep -q '^kind$' \
        || docker network connect kind "$CONTAINER_NAME"
    fi
    local KIND_CONTROL_PLANE_IP="$(docker inspect "$KIND_NAME-control-plane" \
      -f '{{ .NetworkSettings.Networks.kind.IPAddress }}')"
    kind get kubeconfig --name "$KIND_NAME" --internal \
      | sed "s/$KIND_NAME-control-plane/$KIND_CONTROL_PLANE_IP/" \
      > "$HOME/.kube/config-$KIND_NAME"
  else
    kind get kubeconfig --name "$KIND_NAME" \
      > "$HOME/.kube/config-$KIND_NAME"
  fi

  (
  export KUBECONFIG="${KUBECONFIG:-$HOME/.kube/config}"
  if [ -s "$KUBECONFIG" ]
  then
    KUBECONFIG="$HOME/.kube/config-$KIND_NAME":"$KUBECONFIG" \
      kubectl config view --raw > "$HOME/.kube/config-merged"
    mv "$HOME/.kube/config-merged" "$KUBECONFIG"
  else
    mv "$HOME/.kube/config-$KIND_NAME" "$KUBECONFIG"
  fi
  chmod 700 "$KUBECONFIG"
  )

  chmod 700 "$KUBECONFIG"
  # fix for Unable to connect to the server: x509: certificate is valid for <ips>, not <ip>
  kubectl config set "clusters.kind-$KIND_NAME.insecure-skip-tls-verify" --set-raw-bytes true
  kubectl config unset "clusters.kind-$KIND_NAME.certificate-authority-data"
}

reuse_k8s() {
  check_kind_version
  check_kind_image_exists

  try_function update_k8s_config

  if ! kind get clusters | grep -q "^$KIND_NAME$" \
      || ! docker inspect "$KIND_NAME-control-plane" -f '{{ .State.Status }}' \
        | grep -q -F 'running' \
      || ! docker inspect "$KIND_NAME-control-plane" -f '{{ .Config.Image }}' \
        | grep -q -F "kindest/node:v$(get_kind_image "${K8S_VERSION}")"
  then
    echo "Can not reuse kind environment $KIND_NAME"
    reset_k8s
    return
  fi

  echo "Reusing kind environment $KIND_NAME"
}

reset_k8s() {
  check_kind_version
  check_kind_image_exists

  echo "Setting up kind environment $KIND_NAME..."

  if [ -n "$KIND_CONTAINERD_SHARED_CACHE_TYPE" ]
  then
    [ -n "$KIND_CONTAINERD_SHARED_CACHE_PATH" ]
    export KIND_CONTAINERD_SHARED_CACHE_PATH
    export KIND_CONTAINERD_CACHE_PATH="$KIND_CONTAINERD_SHARED_CACHE_PATH/$KIND_NAME"
    export KIND_CONTAINERD_SHARED_CACHE_LOCK="$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/shared-cache-lock
    if [ "$KIND_NAME" = kind-shared ]
    then
      echo "Can not set up shared cache for KIND_NAME=kind-shared since it is reserved to hold the shared cache."
      return 1
    fi

    echo "Setting up kind shared cache using $KIND_CONTAINERD_SHARED_CACHE_TYPE..."

    mkdir -p "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata
    local RESULT
    try_function shared_cache_requires_reset_or_update
    if "$RESULT"
    then
      flock "$KIND_CONTAINERD_SHARED_CACHE_LOCK" \
        "$SHELL" $SHELL_XTRACE "$E2E_PATH/e2e" create_or_update_shared_cache
    else
      create_or_update_shared_cache
    fi
  fi

  if [ -n "$KIND_CONTAINERD_CACHE_PATH" ]
  then
    echo "Setting up kind containerd cache in $KIND_CONTAINERD_CACHE_PATH..."
    if [ "$KIND_CONTAINERD_CACHE_RESET" = true ]
    then
      docker run -v "$KIND_CONTAINERD_CACHE_PATH:/containerd-cache" alpine \
        sh -c 'rm -rf /containerd-cache/*'
    fi
  fi

  if [ -n "$K8S_EXTRA_PORT" ]
  then
    echo "Setting up kind port $K8S_EXTRA_PORT..."
  fi

  delete_k8s
  cat << EOF > "$TARGET_PATH/kind-config.yaml"
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
$(
  if [ -n "$KIND_CONTAINERD_CACHE_PATH" ] || \
    docker system info 2> /dev/null | grep -q "Backing Filesystem: \(zfs\|btrfs\)"
  then
    cat << INNER_EOF
containerdConfigPatches:
- |-
$(
  if [ -n "$KIND_CONTAINERD_CACHE_PATH" ]
  then
    cat << INNER_INNER_EOF
 
 root = "/containerd-cache"
INNER_INNER_EOF
  fi
  if docker system info 2> /dev/null | grep -q "Backing Filesystem: zfs" \
    || ([ -n "$KIND_CONTAINERD_CACHE_PATH" ] \
      && df -T "$KIND_CONTAINERD_CACHE_PATH" | tail -n 1 | tr -s ' ' | cut -d ' ' -f 2 | grep -q '^zfs$')
  then
    cat << INNER_INNER_EOF
 [plugins."io.containerd.grpc.v1.cri".containerd]
 snapshotter = "zfs"
INNER_INNER_EOF
  fi
  if docker system info 2> /dev/null | grep -q "Backing Filesystem: btrfs" \
    || ([ -n "$KIND_CONTAINERD_CACHE_PATH" ] \
      && df -T "$KIND_CONTAINERD_CACHE_PATH" | tail -n 1 | tr -s ' ' | cut -d ' ' -f 2 | grep -q '^btrfs$')
  then
    cat << INNER_INNER_EOF
 [plugins."io.containerd.grpc.v1.cri".containerd]
 snapshotter = "btrfs"
INNER_INNER_EOF
  fi
)
INNER_EOF
  fi
)
networking:
  disableDefaultCNI: true
  apiServerAddress: "0.0.0.0"
nodes:
- role: control-plane
$(
  if [ -n "$K8S_EXTRA_PORT" ]
  then
    cat << INNER_EOF
  extraPortMappings:
  - containerPort: $(echo "$K8S_EXTRA_PORT" | cut -d : -f 1)
    hostPort: $(echo "$K8S_EXTRA_PORT" | cut -d : -f 2)
    listenAddress: "$(echo "$K8S_EXTRA_PORT" | cut -d : -f 3)"
    protocol: "$(echo "$K8S_EXTRA_PORT" | cut -d : -f 4)"
INNER_EOF
  fi
  if [ -n "$KIND_CONTAINERD_CACHE_PATH" ]
  then
    mkdir -p "$KIND_CONTAINERD_CACHE_PATH"
    cat << INNER_EOF
  extraMounts:
  - hostPath: $KIND_CONTAINERD_CACHE_PATH
    containerPath: /containerd-cache
INNER_EOF
  fi
  for KIND_NODE in $(seq 2 "$KIND_NODES")
  do
    cat << INNER_EOF
- role: worker
INNER_EOF
  done
)
EOF

  flock "$KIND_LOCK_PATH" \
    kind create cluster --name "$KIND_NAME" --config "$TARGET_PATH/kind-config.yaml" \
    --image "kindest/node:v$(get_kind_image "${K8S_VERSION}")"

  if [ "$KIND_INSTALL_NFS" = "true" ]
  then
    echo "Setting up NFT tools for kind..."
    kind get nodes --name "$KIND_NAME" \
      | xargs -r -n 1 -I % -P "$E2E_PARALLELISM" sh -ec "
      docker exec '%' sh -c 'DEBIAN_FRONTEND=noninteractive apt-get update -y -qq < /dev/null > /dev/null'
      docker exec '%' sh -c 'DEBIAN_FRONTEND=noninteractive apt-get install -y -qq nfs-common < /dev/null > /dev/null'
      "
  fi

  update_k8s_config

  if [ "${K8S_VERSION%.*}" = 1.12 ]
  then
    echo "Patch coredns to version 1.3.1 (see https://github.com/coredns/coredns/issues/2391)..."
    kubectl patch deployment -n kube-system coredns --type json \
      --patch '[{"op":"replace","path":"/spec/template/spec/containers/0/image","value":"k8s.gcr.io/coredns:1.3.1"}]'
  fi

  echo "Setting up calico for kind..."
  kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml
  kubectl -n kube-system set env daemonset/calico-node FELIX_IGNORELOOSERPF=true

  echo "...done"
}

delete_k8s() {
  check_kind_version

  if kind get clusters | grep -q "^$KIND_NAME$"
  then
    echo "Deleting kind environment $KIND_NAME..."

    kind delete cluster --name "$KIND_NAME" || true

    echo "...done"
  fi

  if [ -n "$KIND_CONTAINERD_CACHE_PATH" ]
  then
    echo "Cleanup kind containerd cache in $KIND_CONTAINERD_CACHE_PATH..."
    docker run -v "$KIND_CONTAINERD_CACHE_PATH:/containerd-cache" alpine \
      sh -c 'ls -1 /containerd-cache/* 2>/dev/null \
        | grep -v /containerd-cache/io.containerd.content.v1.content \
        | xargs rm -rf'
  fi
}

load_image_k8s() {
  check_kind_version

  local IMAGE_ID
  IMAGE_ID="$( (docker inspect --format '{{ .ID }}' "$1" 2>/dev/null || printf unknown) | grep -v '^$')"
  local KIND_IMAGE_ID
  KIND_IMAGE_ID="$( (docker exec "${KIND_NAME}-control-plane" crictl inspecti -o json "$1" 2>/dev/null || printf '{"status": {"id": "unknown"}}') | jq -r '.status.id' | grep -v '^$')"
  if [ "$IMAGE_ID" = unknown ] && [ "$KIND_IMAGE_ID" != unknown ]
  then
    echo "Image $1 already loaded in kind environemnt $KIND_NAME"
    return
  fi
  if [ "$KIND_IMAGE_ID" = "$IMAGE_ID" ]
  then
    echo "Image $1 already loaded in kind environemnt $KIND_NAME"
    return
  fi
  kind load docker-image --name "$KIND_NAME" "$1"

  echo "Loaded image $1 in kind environemnt $KIND_NAME"
}

pull_image_k8s() {
  check_kind_version

  local AUTH
  AUTH="$(jq -r '.auths|to_entries|.[]|.key + "|" + .value.auth' "${HOME}/.docker/config.json" \
    | grep -F "${1%%/*}" | head -n 1 | cut -d '|' -f 2)"
  if [ -n "$AUTH" ]
  then
    docker exec "${KIND_NAME}-control-plane" crictl pull --auth "$AUTH" "$1"
  else
    docker exec "${KIND_NAME}-control-plane" crictl pull "$1"
  fi

  echo "Pulled image $1 in kind environemnt $KIND_NAME"
}

tag_image_k8s() {
  check_kind_version

  docker exec "${KIND_NAME}-control-plane" ctr -n k8s.io images tag --force "$1" "$2"

  echo "Tagged image $1 as $2 in kind environemnt $KIND_NAME"
}

load_certificate_k8s() {
  check_kind_version

  echo "Loading certificate $1 in kind environemnt $KIND_NAME..."

  kind get nodes --name "$KIND_NAME" \
    | xargs -r -n 1 -I % -P "$E2E_PARALLELISM" sh -ec "
    docker cp '$1' '%':/usr/local/share/ca-certificates/validator.crt
    docker exec '%' sh -c "update-ca-certificates"
    "

  echo "...done"
}

excluded_namespaces() {
  echo 'local-path-storage'
}

excluded_clusterroles() {
  echo 'local-path-provisioner-role'
  echo 'calico-.*'
}

excluded_clusterrolebindings() {
  echo 'local-path-provisioner-bind'
  echo 'calico-.*'
}

excluded_customresourcedefinitions() {
  echo '.*\.crd\.projectcalico\.org'
}

get_k8s_versions() {
  get_kind_images | cut -d @ -f 1 | sed 's/^v//'
}

check_kind_image_exists() {
  try_function get_kind_image "${K8S_VERSION}" > /dev/null 2>&1
  if ! "$RESULT"
  then
    echo "Kind image for k8s version ${K8S_VERSION} not found."
    echo "Available images exists only for versions: $(get_k8s_versions | tr '\n' ' ' | sed 's/ /, /g')"
    return 1
  fi
}

get_kind_image() {
  get_kind_images | sed 's/^v//' | grep "^$1@"
}

get_kind_images() {
  cat << EOF
v1.21.1@sha256:fae9a58f17f18f06aeac9772ca8b5ac680ebbed985e266f711d936e91d113bad
v1.20.7@sha256:e645428988191fc824529fd0bb5c94244c12401cf5f5ea3bd875eb0a787f0fe9
v1.19.11@sha256:7664f21f9cb6ba2264437de0eb3fe99f201db7a3ac72329547ec4373ba5f5911
v1.18.19@sha256:530378628c7c518503ade70b1df698b5de5585dcdba4f349328d986b8849b1ee
v1.17.17@sha256:c581fbf67f720f70aaabc74b44c2332cc753df262b6c0bca5d26338492470c17
v1.16.15@sha256:430c03034cd856c1f1415d3e37faf35a3ea9c5aaa2812117b79e6903d1fc9651
v1.15.12@sha256:8d575f056493c7778935dd855ded0e95c48cb2fab90825792e8fc9af61536bf9
v1.14.10@sha256:6033e04bcfca7c5f2a9c4ce77551e1abf385bcd2709932ec2f6a9c8c0aff6d4f
EOF
}

shared_cache_requires_reset_or_update() {
  shared_cache_requires_reset_or_update_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

shared_cache_requires_reset_or_update_hardlink() {
  shared_cache_requires_reset \
    || ( [ "$KIND_CONTAINERD_SHARED_CACHE_UPDATE" = true ] \
      && [ "$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id || true)" != "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" ] )
}

shared_cache_requires_reset_or_update_btrfs() {
  shared_cache_requires_reset \
    || ( [ "$KIND_CONTAINERD_SHARED_CACHE_UPDATE" = true ] \
      && [ "$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id || true)" != "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" ] )
}

shared_cache_requires_reset_or_update_zfs() {
  shared_cache_requires_reset \
    || ! run_as_root_on_host zfs list -t snapshot kind-cache/kind-shared@base >/dev/null 2>&1 \
    || ( [ "$KIND_CONTAINERD_SHARED_CACHE_UPDATE" = true ] \
      && [ "$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id || true)" != "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" ] )
}

shared_cache_requires_reset() {
  shared_cache_requires_reset_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

shared_cache_requires_reset_hardlink() {
  ! [ -f "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/hardlink.ready ] \
    || ( [ "$KIND_CONTAINERD_SHARED_CACHE_RESET" = true ] \
      && [ "$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id || true)" != "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" ] )
}

shared_cache_requires_reset_btrfs() {
  ! [ -f "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/btrfs.ready ] \
    || ( [ "$KIND_CONTAINERD_SHARED_CACHE_RESET" = true ] \
      && [ "$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id || true)" != "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" ] )
}

shared_cache_requires_reset_zfs() {
  ! run_as_root_on_host zfs list kind-cache/kind-shared >/dev/null 2>&1 \
    || ( [ "$KIND_CONTAINERD_SHARED_CACHE_RESET" = true ] \
      && [ "$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id || true)" != "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" ] )
}

reset_others_shared_caches() {
  reset_others_shared_caches_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

reset_others_shared_caches_hardlink() {
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH'/* 2>/dev/null || true
    zfs destroy -r kind-cache 2>/dev/null || true
    zpool destroy kind-cache 2>/dev/null || true
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.btrfs
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.zfs
    "
}

reset_others_shared_caches_btrfs() {
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH'/* 2>/dev/null || true
    zfs destroy -r kind-cache 2>/dev/null || true
    zpool destroy kind-cache 2>/dev/null || true
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.zfs
    "
}

reset_others_shared_caches_zfs() {
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH' 2>/dev/null || true
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.btrfs
    "
}

reset_shared_cache() {
  reset_shared_cache_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

reset_shared_cache_hardlink() {
  echo "Resetting cache using hardlink ..."
  remove_containers_using_shared_cache
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/hardlink.ready
    rm -rf '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    "
  echo "done"
}

reset_shared_cache_btrfs() {
  echo "Resetting cache using btrfs ..."
  remove_containers_using_shared_cache
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/btrfs.ready
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH' 2>/dev/null || true
    losetup -a | grep '/image\.btrfs' | cut -d : -f 1 | xargs -r -I % losetup -d '%'
    rm -rf '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    truncate -s'$KIND_CONTAINERD_SHARED_CACHE_SIZE' '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.btrfs
    losetup -f > '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.device
    losetup '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)' '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mkfs.btrfs '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)'
    "
  echo "done"
}

reset_shared_cache_zfs() {
  echo "Resetting cache using zfs ..."
  remove_containers_using_shared_cache
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH'/* 2>/dev/null || true
    zfs destroy -r kind-cache 2>/dev/null || true
    zpool destroy kind-cache 2>/dev/null || true
    losetup -a | grep '/image\.zfs' | cut -d : -f 1 | xargs -r -I % losetup -d '%'
    rm -rf '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    rm -f '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.zfs
    truncate -s'$KIND_CONTAINERD_SHARED_CACHE_SIZE' '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.zfs
    losetup -f > '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.device
    losetup '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)' '$KIND_CONTAINERD_SHARED_CACHE_PATH'-metadata/image.zfs
    zpool create -f -m legacy -O atime=off -O compression=lz4 -O recordsize=128K  kind-cache '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)'
    zfs create -s -V '$KIND_CONTAINERD_SHARED_CACHE_SIZE' kind-cache/kind-shared
    mkfs.ext4 -F /dev/zvol/kind-cache/kind-shared
    "
  echo "done"
}

pre_update_shared_cache() {
  pre_update_shared_cache_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

pre_update_shared_cache_hardlink() {
  echo "Mounting shared cache using hardlink ..."
  run_as_root_on_host mkdir -p "$KIND_CONTAINERD_SHARED_CACHE_PATH"/kind-shared
  echo "done"
}

pre_update_shared_cache_btrfs() {
  echo "Mounting shared cache using btrfs ..."
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH' 2>/dev/null || true
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mount '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)' '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'/kind-shared
    "
  echo "done"
}

pre_update_shared_cache_zfs() {
  echo "Mounting shared cache using zfs ..."
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH'/kind-shared 2>/dev/null || true
    rm -rf '$KIND_CONTAINERD_SHARED_CACHE_PATH'/kind-shared
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'/kind-shared
    mount /dev/zvol/kind-cache/kind-shared '$KIND_CONTAINERD_SHARED_CACHE_PATH'/kind-shared
    "
  echo "done"
}

update_shared_cache() {
  echo "Updating shared cache ..."
  KIND_NAME=kind-shared \
    KIND_CONTAINERD_CACHE_PATH="$KIND_CONTAINERD_SHARED_CACHE_PATH"/kind-shared \
    KIND_CONTAINERD_SHARED_CACHE_TYPE= \
    "$SHELL" $SHELL_XTRACE "$E2E_PATH/e2e" reset_k8s
  for IMAGE_TAG in $KIND_CONTAINERD_SHARED_CACHE_IMAGE_TAGS
  do
    KIND_NAME=kind-shared \
      KIND_CONTAINERD_CACHE_PATH="$KIND_CONTAINERD_SHARED_CACHE_PATH"/kind-shared \
      KIND_CONTAINERD_SHARED_CACHE_TYPE= \
      IMAGE_TAG="$IMAGE_TAG" \
      "$SHELL" $SHELL_XTRACE "$E2E_PATH/e2e" load_operator_k8s
  done
  if [ -n "$KIND_CONTAINERD_SHARED_CACHE_EXTRA_IMAGES_FILES" ]
  then
    (cat $KIND_CONTAINERD_SHARED_CACHE_EXTRA_IMAGES_FILES 2>/dev/null || true) | sort \
      > "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/extra-images
  fi
  KIND_NAME=kind-shared \
    KIND_CONTAINERD_CACHE_PATH="$KIND_CONTAINERD_SHARED_CACHE_PATH"/kind-shared \
    KIND_CONTAINERD_SHARED_CACHE_TYPE= \
    E2E_PULLED_IMAGES_PATH=/"$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/extra-images \
    "$SHELL" $SHELL_XTRACE "$E2E_PATH/e2e" load_cached_images_from_local_repository 
  KIND_NAME=kind-shared \
    KIND_CONTAINERD_CACHE_PATH="$KIND_CONTAINERD_SHARED_CACHE_PATH"/kind-shared \
    KIND_CONTAINERD_SHARED_CACHE_TYPE= \
    "$SHELL" $SHELL_XTRACE "$E2E_PATH/e2e" delete_k8s
  echo "done"
}

post_update_shared_cache() {
  post_update_shared_cache_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
  echo "$KIND_CONTAINERD_SHARED_CACHE_RUN_ID" > "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/reset-run-id
}

post_update_shared_cache_hardlink() {
  touch "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/hardlink.ready
}

post_update_shared_cache_btrfs() {
  touch "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/btrfs.ready
}

post_update_shared_cache_zfs() {
  echo "Generating shared cache snapshot using zfs ..."
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    zfs destroy kind-cache/kind-shared@base 2>/dev/null || true
    zfs snap kind-cache/kind-shared@base
    "
  echo "done"
}

pre_cache() {
  pre_cache_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

pre_cache_hardlink() {
  true
}

pre_cache_btrfs() {
  true
}

pre_cache_zfs() {
  true
}

cache_requires_reset() {
  cache_requires_reset_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

cache_requires_reset_hardlink() {
  ! run_as_root_on_host [ -f "$KIND_CONTAINERD_CACHE_PATH"/updated ] \
    || [ "$KIND_CONTAINERD_CACHE_RESET" = true ]
}

cache_requires_reset_btrfs() {
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH' 2>/dev/null || true
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mount '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)' '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    ! [ -f '$KIND_CONTAINERD_CACHE_PATH'/updated ] \
      || [ '$KIND_CONTAINERD_CACHE_RESET' = true ]
    "
}

cache_requires_reset_zfs() {
  ! run_as_root_on_host zfs list kind-cache/"$KIND_NAME" >/dev/null 2>&1 \
    || [ "$KIND_CONTAINERD_CACHE_RESET" = true ]
}

reset_cache() {
  reset_cache_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

reset_cache_hardlink() {
  echo "Resetting cache for $KIND_NAME using hardlink ..."
  docker rm -fv "$KIND_NAME"-control-plane 2>/dev/null
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    rm -rf '$KIND_CONTAINERD_CACHE_PATH'
    mkdir -p '$KIND_CONTAINERD_CACHE_PATH'
    "'
    (
      (
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.content.v1.content -type d
      ls -1d "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.snapshotter.v1.overlayfs
      ls -1d "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.snapshotter.v1.overlayfs/snapshots
      ls -1d "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.snapshotter.v1.overlayfs/snapshots/*
      ls -1d "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.snapshotter.v1.overlayfs/snapshots/*/*
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.snapshotter.v1.overlayfs/snapshots/*/fs -type d
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.metadata.v1.bolt -type d
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.runtime.v1.linux -type d
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.runtime.v2.task -type d
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.grpc.v1.cri -type d
      ) | xargs -n 1 echo "mkdir "
      (
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.content.v1.content -type f
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.snapshotter.v1.overlayfs/snapshots/*/fs -type f
      ) | xargs -n 1 echo "ln "
      (
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.metadata.v1.bolt -type f
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.runtime.v1.linux -type f
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.runtime.v2.task -type f
      find "'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'"/kind-shared/io.containerd.grpc.v1.cri -type f
      ) | xargs -n 1 echo "cp "
    ) | while read OP FILE
        do
          TARGET="'"$KIND_CONTAINERD_CACHE_PATH"'/${FILE#'"$KIND_CONTAINERD_SHARED_CACHE_PATH"'/kind-shared/}"
          if [ "$OP" = mkdir ]
          then
            mkdir -p "$TARGET"
          elif [ "$OP" = ln ]
          then
            ln "$FILE" "$TARGET"
          elif [ "$OP" = cp ]
          then
            cp -a "$FILE" "$TARGET"
          fi
        done
      '"
    touch '$KIND_CONTAINERD_CACHE_PATH'/updated
    "
  echo "done"
}

reset_cache_btrfs() {
  echo "Resetting cache for $KIND_NAME using btrfs ..."
  docker rm -fv "$KIND_NAME"-control-plane 2>/dev/null
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH' 2>/dev/null || true
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mount '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)' '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    rm -rf '$KIND_CONTAINERD_CACHE_PATH'
    mkdir -p '$KIND_CONTAINERD_CACHE_PATH'
    cp -r --reflink '$KIND_CONTAINERD_SHARED_CACHE_PATH'/kind-shared/. \
      '$KIND_CONTAINERD_CACHE_PATH'/.
    touch '$KIND_CONTAINERD_CACHE_PATH'/updated
    "
  echo "done"
}

reset_cache_zfs() {
  echo "Resetting cache for $KIND_NAME using zfs ..."
  docker rm -fv "$KIND_NAME"-control-plane 2>/dev/null
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_CACHE_PATH' 2>/dev/null || true
    rm -rf '$KIND_CONTAINERD_CACHE_PATH'
    zfs destroy kind-cache/'$KIND_NAME' 2>/dev/null || true
    zfs clone kind-cache/kind-shared@base kind-cache/'$KIND_NAME'
    "
  echo "done"
}

mount_cache() {
  mount_cache_"$KIND_CONTAINERD_SHARED_CACHE_TYPE"
}

mount_cache_hardlink() {
  true
}

mount_cache_btrfs() {
  echo "Mount cache for $KIND_NAME using btrfs ..."
  docker rm -fv "$KIND_NAME"-control-plane 2>/dev/null
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_SHARED_CACHE_PATH' 2>/dev/null || true
    mkdir -p '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    mount '$(cat "$KIND_CONTAINERD_SHARED_CACHE_PATH"-metadata/image.device)' '$KIND_CONTAINERD_SHARED_CACHE_PATH'
    "
  echo "done"
}

mount_cache_zfs() {
  echo "Mount cache for $KIND_NAME using zfs ..."
  docker rm -fv "$KIND_NAME"-control-plane 2>/dev/null
  run_as_root_on_host sh -ec $SHELL_XTRACE "
    umount '$KIND_CONTAINERD_CACHE_PATH' 2>/dev/null || true
    rm -rf '$KIND_CONTAINERD_CACHE_PATH'
    mkdir -p '$KIND_CONTAINERD_CACHE_PATH'
    mount /dev/zvol/kind-cache/'$KIND_NAME' '$KIND_CONTAINERD_CACHE_PATH'
    "
  echo "done"
}

remove_containers_using_shared_cache() {
  docker ps --format '{{ .ID }} {{ .Mounts }}' --no-trunc \
    | grep "\(^\|,\)$KIND_CONTAINERD_SHARED_CACHE_PATH/" \
    | tr -s ' ' | cut -d ' ' -f 1 | xargs -r -I % docker rm -fv %
}

create_or_update_shared_cache() {
  echo "Shared kind cache feature is broken! Code is here for future reference, remove this and next lines to try it at your own risk!"
  return 1
  reset_others_shared_caches
  if shared_cache_requires_reset_or_update
  then
    if shared_cache_requires_reset
    then
      reset_shared_cache
    fi
    pre_update_shared_cache
    update_shared_cache
    post_update_shared_cache
  fi
  pre_cache
  if cache_requires_reset
  then
    reset_cache
  fi
  mount_cache
}
